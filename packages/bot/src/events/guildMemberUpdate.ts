/**
 * Guild Member Update Event
 *
 * Handles role changes for automatic license management
 */

import { Events, GuildMember } from 'discord.js';
import { logger } from '@dca-auth/shared/logging/logger';
import { licenseKeyService } from '@dca-auth/shared/licenses';
import { auditService } from '@dca-auth/shared/services/audit.service';
import { AuditAction, LicenseKeyType } from '@prisma/client';
import type { Event } from '../types/event.js';

export const event: Event<Events.GuildMemberUpdate> = {
  name: Events.GuildMemberUpdate,
  async execute(client, oldMember, newMember) {
    try {
      // Check if roles have changed
      const oldRoles = oldMember.roles.cache;
      const newRoles = newMember.roles.cache;

      const addedRoles = newRoles.filter(role => !oldRoles.has(role.id));
      const removedRoles = oldRoles.filter(role => !newRoles.has(role.id));

      if (addedRoles.size === 0 && removedRoles.size === 0) {
        return; // No role changes
      }

      // Get user from database
      const user = await client.prisma.user.findUnique({
        where: { discordId: newMember.user.id },
        include: { ownedLicenses: true },
      });

      if (!user) {
        // User not registered in system
        return;
      }

      // Get guild configuration
      const guildConfig = await client.prisma.guildConfig.findUnique({
        where: { guildId: newMember.guild.id },
      });

      if (!guildConfig || !guildConfig.roleSync) {
        return; // Role sync not enabled for this guild
      }

      // Handle added roles
      for (const [roleId, role] of addedRoles) {
        await handleRoleAdded(client, user, newMember, role, guildConfig);
      }

      // Handle removed roles
      for (const [roleId, role] of removedRoles) {
        await handleRoleRemoved(client, user, newMember, role, guildConfig);
      }

    } catch (error) {
      logger.error('Error handling guild member update', {
        error,
        memberId: newMember.user.id,
        guildId: newMember.guild.id,
      });
    }
  },
};

/**
 * Handle when a role is added to a member
 */
async function handleRoleAdded(
  client: any,
  user: any,
  member: GuildMember,
  role: any,
  guildConfig: any
): Promise<void> {
  try {
    // Check if this role grants a license
    const roleConfig = guildConfig.roleConfigs?.find((rc: any) => rc.roleId === role.id);

    if (!roleConfig || !roleConfig.grantLicense) {
      return;
    }

    // Check if user already has an active license for this role
    const existingLicense = user.ownedLicenses.find((license: any) =>
      license.metadata?.roleId === role.id &&
      license.status === 'ACTIVE' &&
      (!license.expiresAt || license.expiresAt > new Date())
    );

    if (existingLicense) {
      logger.debug('User already has active license for role', {
        userId: user.id,
        roleId: role.id,
      });
      return;
    }

    // Create a new license for the user
    const license = await licenseKeyService.createLicenseKey(
      {
        type: roleConfig.licenseType || LicenseKeyType.SUBSCRIPTION,
        ownerId: user.id,
        name: `${role.name} License`,
        maxActivations: roleConfig.maxActivations || 1,
        expiresAt: roleConfig.duration
          ? new Date(Date.now() + roleConfig.duration * 1000)
          : undefined,
        features: roleConfig.features || {},
        metadata: {
          roleId: role.id,
          roleName: role.name,
          guildId: member.guild.id,
          guildName: member.guild.name,
          autoGenerated: true,
        },
        autoActivate: true,
      },
      'system' // Created by system
    );

    // Send DM to user about new license
    try {
      await member.user.send({
        embeds: [{
          title: 'New License Granted',
          description: `You've been granted a license key for having the **${role.name}** role!`,
          fields: [
            { name: 'License Key', value: `\`${license.shortKey}\``, inline: true },
            { name: 'Type', value: license.type, inline: true },
            { name: 'Max Activations', value: license.maxActivations.toString(), inline: true },
          ],
          color: 0x00ff00,
          timestamp: new Date().toISOString(),
        }],
      });
    } catch (error) {
      logger.warn('Failed to DM user about new license', {
        userId: user.id,
        error,
      });
    }

    // Log audit event
    await auditService.log({
      userId: user.id,
      action: AuditAction.LICENSE_CREATED,
      entityType: 'license_key',
      entityId: license.id,
      details: {
        reason: 'Role granted',
        roleId: role.id,
        roleName: role.name,
        guildId: member.guild.id,
      },
    });

    logger.info('License granted for role', {
      userId: user.id,
      licenseId: license.id,
      roleId: role.id,
      guildId: member.guild.id,
    });

  } catch (error) {
    logger.error('Failed to grant license for role', {
      error,
      userId: user.id,
      roleId: role.id,
    });
  }
}

/**
 * Handle when a role is removed from a member
 */
async function handleRoleRemoved(
  client: any,
  user: any,
  member: GuildMember,
  role: any,
  guildConfig: any
): Promise<void> {
  try {
    // Check if this role had granted a license
    const roleConfig = guildConfig.roleConfigs?.find((rc: any) => rc.roleId === role.id);

    if (!roleConfig || !roleConfig.grantLicense || !roleConfig.revokeOnRemove) {
      return;
    }

    // Find licenses associated with this role
    const roleLicenses = user.ownedLicenses.filter((license: any) =>
      license.metadata?.roleId === role.id &&
      license.metadata?.autoGenerated === true &&
      license.status === 'ACTIVE'
    );

    for (const license of roleLicenses) {
      // Revoke the license
      await licenseKeyService.revokeLicenseKey(
        license.id,
        'Role removed',
        'system'
      );

      // Send DM to user about revoked license
      try {
        await member.user.send({
          embeds: [{
            title: 'License Revoked',
            description: `Your license has been revoked because you no longer have the **${role.name}** role.`,
            fields: [
              { name: 'License Key', value: `\`${license.shortKey}\``, inline: true },
              { name: 'Reason', value: 'Role removed', inline: true },
            ],
            color: 0xff0000,
            timestamp: new Date().toISOString(),
          }],
        });
      } catch (error) {
        logger.warn('Failed to DM user about revoked license', {
          userId: user.id,
          error,
        });
      }

      // Log audit event
      await auditService.log({
        userId: user.id,
        action: AuditAction.LICENSE_REVOKED,
        entityType: 'license_key',
        entityId: license.id,
        details: {
          reason: 'Role removed',
          roleId: role.id,
          roleName: role.name,
          guildId: member.guild.id,
        },
      });

      logger.info('License revoked for role removal', {
        userId: user.id,
        licenseId: license.id,
        roleId: role.id,
        guildId: member.guild.id,
      });
    }

  } catch (error) {
    logger.error('Failed to revoke license for role removal', {
      error,
      userId: user.id,
      roleId: role.id,
    });
  }
}

export default event;